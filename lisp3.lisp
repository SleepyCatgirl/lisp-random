;; and or
(defun small-pos-oddp (x)
  (and (< x 100)
       (> x 0)
       (oddp x)))
(defun how-alike (a b)
  (cond ((equal a b) 'the-same)
        ((and (oddp a) (oddp b)) 'both-odd)
        ((and (not (oddp a)) (not (oddp b))) 'both-even)
        ((and (< a 0) (< b 0)) 'both-negative)
        (t 'not-alike)))
(defun same-sign (x y)
  (or (and (zerop x) (zerop y))
      (and (< x 0) (< y 0))
      (and (> x 0) (> y 0))))
(defun geq (x y)
  (or (> x y) (equal x y)))
(defun function-nya (x)
  (cond ((and (oddp x) (> x 0)) (* x x))
        ((and (oddp x) (< x 0)) (* x 2))
        (t (/ x 2))))
(defun personp (list)
  (cond ((and (or (equal 'boy (car list))
                  (equal 'girl (car list))) (equal
                                                (car (
                                                      cdr list)) 'child) t))
        ((and (or (equal 'man (car list))
                  (equal 'woman (car list))) (equal
                                              (car (
                                                    cdr list))
                                              'adult)))
        (t nil)))
(defun personp-2 (x y)
  (or (and (or (equal x 'boy) (equal x 'girl)) (equal y 'child))
      (and (or (equal x 'man) (equal x 'woman)) (equal y 'adult))))
;;(defun rps (x y)
;;  (cond ((equal x y) 'tie)
;;        ((equal 'rock 'scissors) 'first-wins)
;;        ((equal 'rock 'paper) 'second-wins)
;;        ((equal 'paper 'rock) 'first-wins)
;;        ((equal 'paper 'scissors) 'second-wins)
;;        ((equal 'scissors 'rock) 'second-wins)
;;        ((equal 'scissors 'paper) 'first-wins)))
(defun rps-2 (x y)
  (cond ((equal x y) 'tie)
        ((or (and (equal x 'rock)
                  (equal y 'scissors))
             (and (equal x 'scissors)
                  (equal y 'paper))
             (and (equal x 'paper)
                  (equal y 'rock))) 'first-wins)
        (t 'second-wins)))
(defun posnump (x)
  (and (numberp x) (plusp x)))
;; and or can be implemented using cond or if
(defun posnump-if (x)
  (if (numberp x) (> x 0) nil))
(defun posnump-conf (x)
  (cond ((numberp x) (> x 0))
        (t nil)))
(defun compare-if (x y)
  (if (equal x y) 'numbers-are-the-same
      (if (< x y) 'first-is-smaller
          'first-is-bigger)))
(defun compare-and-or (x y)
  (or (and (equal x y) 'same-num)
      (and (< x y) 'less-than)
      (and (> x y) 'more-than)))
(defun gtest-if (x y)
  (if (> x y) t
      (if (zerop x) t (zerop y))))
(defun gtest-cond (x y)
  (cond ((> x y) t)
        ((zerop x) t)
        ((zerop y) t)
        (t nil)))
(defun boilingp (temp scale)
  (cond ((equal scale 'celsius) (> temp 100))
        ((equal scale 'far) (> temp 212))))
(defun boilingp-if (temp scale)
  (if (equal scale 'celsius) (> temp 100)
      (if (equal scale 'far) (> temp 212) nil)))
(defun boilingp-or (temp scale)
  (or (and (equal scale 'celsius) (> temp 100))
      (and (equal scale 'far) (> temp 212))))
(defun logical-and (x y) (and x y t))
(defun logical-if (x y)
  (if x (if y t nil) nil))
(defun logical-cond (x y)
  (cond (x t)
        (y t)
        (t nil)))
;; demorgan theorem
;; and = or + not
;; or = and + not
;; (and x y) = (not (or (not x) (not y)))
;; (or x y) = (not (and (not x) (not y)))
;; First: If x and Y are true,
;; then neither is X false nor is Y false
;; second: If tiehrer x or y is true, then x and y
;; cant both be false
(defun demorgan-and (x y)
  (not (or (not x) (not y))))
(defun demorgan-or (x y)
  (not (and (not x) (not y))))

(defun nya ()
  (nya))
