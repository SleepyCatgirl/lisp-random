(setf database
      '((b1 shape brick)
        (b1 color green)
        (b1 size small)
        (b1 supported-by b2)
        (b1 supported-by b3)
        (b2 shape brick)
        (b2 color red)
        (b2 size small)
        (b2 supports b1)
        (b2 left-of b3)
        (b3 shape brick)
        (b3 color red)
        (b3 size small)
        (b3 supports b1)
        (b3 right-of b2)
        (b4 shape pyramid)
        (b4 color blue)
        (b4 size large)
        (b4 supported-by b5)
        (b5 shape cube)
        (b5 color green)
        (b5 size large)
        (b5 supports b4)
        (b6 shape brick)
        (b6 color purple)
        (b6 size large)))

(defun match-element (symbol1 symbol2)
  (or (equal symbol1 symbol2) (equal symbol2 '?)))
(defun match-triple (list1 list2)
  (every #'match-element list1 list2))
(defun fetch (pattern)
  (remove-if-not #'(lambda (x) (match-triple x pattern)) database))

(defun color-ask (block-name)
  (list block-name 'color '?))
;;(defun constructors-base (block-name)
;;  (fetch (list block-name 'supported-by '?)))
;;(defun constructors (block-name)
;;  (mapcar #'(lambda (x) (third x)) (constructors-base block-name)))

(defun supporters (block-name)
  (mapcar #'car (fetch (list '? 'supports block-name))))
(defun supp-cube (block-name)
  (member 'cube (mapcar #'(lambda (x) (third (first (fetch (list x 'shape '?))))) (supporters block-name))))



(defun desc1 (block-name)
  (fetch (list block-name '? '?)))
(defun desc2 (block-name)
  (mapcar #'cdr (desc1 block-name)))
(defun description (block-name)
  (reduce #'append (desc2 block-name)))
